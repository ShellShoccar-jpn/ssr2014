\section{YYYYMMDDhhmmssの各単位を簡単に分離する}

\subsection*{問題}
\noindent
$\!\!\!\!\!$
\begin{grshfboxit}{160.0mm}
	\verb|20140919190454|→\verb|2014年9月19日 19時4分54秒| \\
	というように、年月日時分秒の14桁数字を任意のフォーマットに変換したいが、
	AWKでsubstr()関数を6回も呼ぶことになり、長ったらしくなるし、面倒くさい！簡単に書けないのか。
\end{grshfboxit}

\subsection*{回答}
まず正規表現で数字2桁ずつに半角スペースで分離し、先頭の2組（4桁）だけ結合し直す。
すると年月日時分秒の各要素がスペース区切りになるので、AWKで各フィールドを取り出せば如何様にでもフォーマットできる。

次のコードを実行すれば、\verb|2014年9月19日 19時4分54秒|という文字列に簡単に変換できる。\\
\begin{frameboxit}{160.0mm}
\begin{verbatim}
	echo 20140919190454                                              |
	sed 's/[0-9][0-9]/ &/g'                                          |
	sed 's/ \([0-9][0-9]\) /\1/'                                     |
	awk '{printf("%d年%d月%d日 %d時%d分%d秒\n",$1,$2,$3,$4,$5,$6);}'
\end{verbatim}
\end{frameboxit}

AWKコマンド1つで行うことも可能だ。\\
\begin{frameboxit}{160.0mm}
\begin{verbatim}
	echo 20140919190454           |
	awk '
	  gsub(/[0-9][0-9]/, "& ");
	  sub(/ /, "");
	  split($0, t);
	  printf("%d年%d月%d日 %d時%d分%d秒\n",t[1],t[2],t[3],t[4],t[5],t[6]);
	}'
\end{verbatim}
\end{frameboxit}

\subsection*{解説}

ちょっと頭を捻ってみよう。
アイデアとしては、正規表現で2桁ずつの数字にスペース区切りで分解した後、最初の4個は戻してやればいいわけだ。
つまり正規表現フィルターに2回掛けるわけだが、1つ目はグローバルマッチで、2つ目は1回だけマッチさせるようにすると、
西暦だけ都合よく4桁にできる。

これで年月日時分秒が各々スペース区切りになっているので、AWKで受け取れば自動的に\verb|$1|～\verb|$6|に格納されるし、
あるいは1個のAWKの中で加工していたのであればsplit()関数を使って配列変数に入る。

このテクニックを知らないうちは、
\begin{verbatim}
	echo 20140919190454 |
	awk '
	  Y = substr($0, 1,4);
	  M = substr($0, 5,2);
	  D = substr($0, 7,2);
	  h = substr($0, 9,2);
	  m = substr($0,11,2);
	  s = substr($0,13,2);
	  printf("%d年%d月%d日 %d時%d分%d秒\n",Y,M,D,h,m,s);
	'
\end{verbatim}

\noindent
と書かざるを得なかったのだから、カッコいいコードになったと思う。
