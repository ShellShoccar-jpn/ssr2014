\section{sedによる改行文字への置換を、綺麗に書く}
\label{recipe:sed_LF}

\subsection*{問題}
\noindent
$\!\!\!\!\!$
\begin{grshfboxit}{160.0mm}
	sedコマンドで任意の文字列（説明のため``\verb|\n|''とする）を改行コードに置換したい場合、
	GNU版でないsedでも通用するように書くには
	\begin{verbatim}
		sed 's/\\n/\
		/g'
	\end{verbatim}
	と書かねばならない。しかしこれは綺麗な書き方ではないので何とかしたい。
\end{grshfboxit}

\subsection*{回答}
シェル変数に改行コードを代入しておき、置換後の文字列をしている場所にそのシェル変数を書けば綺麗に書ける。ただし、末尾に改行コードのある文字列をシェル変数に代入するには一工夫必要だ。

まとめると、次のように書ける。
\paragraph{改行コードへの置換を綺麗に書く} 　\\
\begin{frameboxit}{160.0mm}
\begin{verbatim}
	# --- sedにおいて改行コードを意味する文字列の入ったシェル変数を作っておく ---
	LF=$(printf '\\n_')
	LF=${LF%_}

	# --- 標準入力テキストデータに含まれる"\n"を改行コードに置換する ---
	sed 's/\\n/'"$LF"'/g'
\end{verbatim}
\end{frameboxit}

\subsection*{解説}

例えば入力テキストに含まれる``\verb|\n|''という文字列を本当の改行に置換したいという場合、sedでもちゃんとできることはできるのだが記述が少々汚くなってしまう\footnote{GNU版sedなら独自拡張により置換後の文字列指定にも``\verb|\n|''という記述が使えるが、それはsed全般に通用する話ではない。}。インデントしていない場合はまだしも、インデントしている場合の見た目の汚さは最悪だ。\\
\begin{frameboxit}{160.0mm}
\begin{verbatim}
	# --- インデントしてない場合はまだマシ ---
	cat textdata.txt |
	sed 's/\\n/\
	/g'              |
	wc -l

	# --- インデントしている場合は汚いったらありゃしない ---
	find /TARGET/DIR |
	while read file; do
	    cat "$file"  |
	    sed 's/\\n/\
	/g'              |
	    wc -l
	done
\end{verbatim}
\end{frameboxit}

これを綺麗に書く方法は「回答」で示したとおり、``\verb|\|''と改行コード（$<$0x0A$>$）の入ったシェル変数を作り、それを置換後の文字列として指定してやればよい。

\subsubsection*{改行で終わる文字列の入ったシェル変数を作る}

そのシェル変数を作る際、次のように即値で記述することもできる。
\begin{verbatim}
	LF='\
	'
\end{verbatim}

しかしこれでは結局、ソースコードを綺麗に書くという目的の達成はできていない。そこで、printfコマンドを使って``\verb|\|''と改行コード（$<$0x0A$>$）の文字列を動的に生成し、それをシェル変数に代入するのだが、直接代入しようとすると失敗する。それは、コマンドの実行結果を返す``\verb|$(～)|''あるいは``\verb|`～`|''という句が、実行結果の最後に改行があるとそれを取り除いてしまうからだ。

取り除かれないようにするには、改行コードの後ろにとりあえずそれ以外の文字の付けた文字列を生成して代入してしまう。そして、シェル変数のトリミング機能（この場合は右トリミングの``\verb|%|''）を使い、先程付けていた文字列を取り除いて再代入する。この時は``\verb|$(～)|''句を使っていないから、文字列の末尾が改行であっても問題無く代入できるのである。

\subsubsection*{シェル変数をsedに混ぜて使う場合の注意点}

ここで作ったシェル変数を用いて今回の置換処理を記述する時、
\begin{verbatim}
	sed 's/\\n/'$LF'/g'
\end{verbatim}
と書かないように注意。\verb|$LF|をダブルクォーテーションで囲まなければならない。ダブルクォーテーションで囲まれなかったシェル変数は、その中に半角スペースやタブ、改行コードがあるとそこで分割された複数の引数があるものと解釈されてしまう。つまり、``\verb|s/\\n/\|''と``\verb|/g|''が別々の引数であると解釈され、エラーになってしまうからだ。

これはsedに限った話ではないので、コマンド引数をシェル変数と組み合わせて生成する時は常に注意すること。