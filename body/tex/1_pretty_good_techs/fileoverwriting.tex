\section{一時ファイルを作らずファイルを更新する}
\label{recipe:fileoverwriting}

\subsection*{問題}
\noindent
$\!\!\!\!\!$
\begin{grshfboxit}{160.0mm}
	sedやnkfなど一部のコマンドでは、一時ファイルを使わずに内容を直接上書きする機能があるが、
	他のコマンドやシェルスクリプトではできないのか？
	いちいち一時ファイルに書き出してから元のファイルに再び書き戻すのは面倒だ。
\end{grshfboxit}

\subsection*{回答}
できる（大抵のファイルは）。ただしできないファイルもあるので、まずは次で可否を確かめること。
\begin{description}
  \item[ハードリンクが他に存在するファイル] \mbox{}\\→できない。
  \item[所有者等が他人のファイル] \mbox{}\\→できない。
  \item[シンボリックリンク] \mbox{}\\→実体を探し、それが上記に該当しないファイルならばできる。
  \item[ACL付ファイル] \mbox{}\\→ACL情報を保存し、復元すればできる。
  \item[デフォルトと違うパーミッションを持つファイル] \mbox{}\\→パーミッション情報を保存し、復元すればできる。
  \item[上記に該当しないファイル] \mbox{}\\→できる。
\end{description}

確認の結果、できるファイルであったとする。今、対象ファイルのパスがシェル変数\verb|$file|に入っていて、更新のために通したいコマンドが\verb!CMD1 | CMD2 | ...!だったならば、
次のように記述すればよい。これで一時ファイル無しの上書き更新ができる。
\begin{quotation}
	\verb!(rm "$file" && CMD1 | CMD2 | ... > "$file") < "$file"!
\end{quotation}

\subsubsection*{シンボリックリンクであった場合に実体を探す方法}
シンボリックリンクであったらリンク元である実体ファイルを探し、それに対して前記のコードを実行しなければならない。
もしシンボリックリンクに対して実行してしまうと、元のファイルは更新されずに残り、シンボリックリンクは更新された内容で実体化してしまう。

POSIXの範囲を超えるのがアリなら、次のようにreadlinkコマンドを使えば実体のパスを簡単に得ることができる。
\begin{quotation}
	\verb!file=$(readlink -f "!\textit{対象シンボリックリンクへのパス}\verb!")!
\end{quotation}
``\verb|-f|''オプションは、リンク先がまたリンクであった場合に再帰的に実体を探すためのものである。これでシェル変数\verb!$file!に実体が（存在すれば）代入されるので、この後先程と同様に\verb!(rm "$file" && CMD1 ...!を実行すればよい。

だが、本書はPOSIX原理主義者のためのものであるからもちろんそれで済ませはしない。前記の\verb!readlink -f!に相当するコードをPOSIXの範囲で書くとこうなる。

\paragraph{readlink -f相当を、POSIXの範囲で実装する} 　\\
\begin{frameboxit}{160.0mm}
\begin{verbatim}
	while :; do
	  # 1) lsコマンドで、属性とファイルサイズを取ってくる
	  s=$(ls -adl "$file" 2>/dev/null) || {
	    printf '%s: cannot open "%s" (Permission denied)\n' "${0##*/}" "$file" 1>&2
	    exit 1
	  }
	  # 2) lsが返した文字列を要素毎に分割
	  set -- $s # 属性は$1に格納、ファイルサイズは$5に格納される
	  # 3) 実ファイルを見つけるためのループ
	  #    ・そもそも見つからなければエラー終了
	  #    ・通常ファイルならそのファイル名でループ終了
	  #    ・リンクならリンク元のパスを調べて再度ループ
	  #    ・それ以外のファイルならエラー終了
	  case "$1" in
	    '') printf '%s: %s: No such file or directory\n' "${0##*/}" "$file" 1>&2
	        exit 1
	        ;;
	    -*) break
	        ;;
	    l*) s=$(printf '%s' "$file"         |
	            sed 's/\([].\*/[]\)/\\\1/g' |
	            sed 's/^\^/\\^/'            |
	            sed 's/\$$/\\$/'            )
	        srcfile=$(file "$file"                              |
	                  sed 's/^.\{'"$s"'\}: symbolic link to //' |
	                  sed 's/^`\(.*\)'"'"'$/\1/'                )
	        case "$srcfile" in                 # fileコマンドが↑の書式で
	          /*) file=$srcfile             ;; # 返してくることは
	           *) file="${file%/*}/$srcfile";; # POSIXで保証されている
	        esac
	        continue
	        ;;
	     *) printf '%s\n' "${0##*/}: \`$file' is not a regular file." 1>&2
	        exit 1
	        ;;
	  esac
	done
\end{verbatim}
\end{frameboxit}
先程と同じくシェル変数\verb!$file!に実体が（存在すれば）代入されるので、あとは同様である。

\subsubsection*{ACL付やパーミッションが変更されているファイルへの対応}

これらの場合は、上書き更新を実施する前にそれらの情報を保存しておかなければならない。次のコードはパーミッションとACLを維持するための例だ。

\paragraph{元のパーミッションとACLも維持しつつ上書き更新する} 　\\
\begin{frameboxit}{160.0mm}
\begin{verbatim}
	file=対象ファイルのパス # シンボリックリンクなら実体を探しておくこと

	# パーミッションと、ACL情報（あれば）の保存
	perm=$(ls -adl "$file" | awk '{print substr($0,1,11)}')
	case "$perm" in
	  [^-]*) echo "Not a regular file" 1>&2;exit 1;;
	   *'+') acl=$(getfacl "$file")               ;;
	      *) acl=''                               ;;
	esac

	# パーミッションをchmodで使える形式(4桁ゼロ埋め8進数)に変換
	perm=$(echo "$perm"                                                     |
	       sed 's/.\(..\)\(.\)\(..\)\(.\)\(..\)\(.\)./\2\4\6 \1\2\3\4\5\6/' |
	       awk '{gsub(/[x-]/,"0",$1);gsub(/[^0]/,"1",$1);print $1 $2;}'     |
	       tr 'STrwxst-' '00111110'                                         |
	       xargs printf 'ibase=2;%s\n'                                      |
	       bc                                                               |
	       xargs printf '%04o'                                              )

	# 一時ファイルを作らず上書き更新
	(rm "$file" && CMD1 | CMD2 | ... > "file") < "$file"

	# パーミッション・ACL（あれば）の復元
	chmod $perm "$file"
	case "$acl" in '') :;; *) printf '%s' "$acl" | setfacl -M - "$file";; esac
\end{verbatim}
\end{frameboxit}
lsコマンドの``\verb|-l|''オプションが第1列に出力する文字列を見ている。それに基づいてパーミッション文字列をchmodコマンド用に8進数化し、保存・復元すると共に、ACL情報の有無を確認し、あればそれも保存・復元している。

\subsection*{解説}

\subsubsection*{一時ファイル無しで上書きするトリック}

そもそも、\verb!(rm "$file" && CMD1 ...!というコードを書くとなぜ一時ファイル無しで上書きができるのだろうか。

UNIXにおいて、rmコマンド等による削除（unlink）は、ファイルの実体を消すのではなくinodeと呼ばれる見出しを消すだけであることは御存知のとおり。つまり、ファイルが直ちに消滅するわけでなない。

もし、誰かがファイルをオープンしている途中に削除したらどうなるかというと、以後は誰もファイルを二度とオープンできなくなるものの、そのファイルを既にオープンしているプロセスはクローズするまで使い続けることができる。
つまり、ファイルをオープンして中身を読み出している間にそのファイルを削除をしてしまっても、読み出しは最後まで行えるのだ。そこですかさず読み出されたデータを受け取って好きな加工を施した上で、同名（2代目）のファイルを新規作成する。

同名のファイルなど作れないように思うが、初代のファイル実体は既にinodeを失っているために無名である。よって2代目ファイルを全く同じ名前で作成可能なのである。

\subsubsection*{リンク付・所有者が他人のファイルが不可な理由}

先に、ハードリンク付・所有者が他人であるかどうか確認する方法を記すが、それらはどちらもlsコマンドの``\verb!-l!''オプションを使えばわかる。

例えば、\verb|ls -l|を実行した結果次のように表示されたとする。
\begin{screen}
	\verb|$ ls -l readme.txt| \return \\
	\verb|-rw-rw-r--+ 3 mikan     staff   3513 Jun  1 18:43 readme.txt| \\
	\verb|$ |
\end{screen}

ここで、第2列の数字は、自分を含めて同じ実体を共有しているハードリンクの数である。これが1でないと本レシピは使えない。理由は、共有している他のハードリンクの名前を知る術がなく、本レシピの方法で一旦削除してしまうとリンクし直せなくなってしまうからである。

一方、第3列、第4列にはファイルの所有者と所有グループが表示されているが、これらが自分でなければ本レシピは使えない。理由は、一般ユーザー権限では所有者と所有グループを他人のものにすることができず、元の状態に戻せないからである。
