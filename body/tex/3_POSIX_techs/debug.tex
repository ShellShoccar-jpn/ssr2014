\section{デバッグってどうやってるの？}
\label{recipe:debug}

\subsection*{問題}
\noindent
$\!\!\!\!\!$
\begin{grshfboxit}{160.0mm}
	シェルスクリプトのIDE（統合開発環境）なんて聞いたこと無い（テキストエディターまでは聞いたことあるが）。

	シェルスクリプトのプログラムに対しては、一体どうやってデバッグを行うのか？
\end{grshfboxit}

\subsection*{回答}

まず基本的な心構えとして、プログラムを新規に書いている段階では、一ステップ書いては動作が正しいか確認するべきだろう。
もちろんリリース後に不具合が見つかった時にもデバッグはするのだが、リリース前に一気にデバッグはしない。結果的にその方が制作が早いと感じているからだ。

では具体的にはどんな手段でデバッグをするかといえば、
\begin{itemize}
  \item 連携しているアプリケーションの各種ログを確認する。
  \item 気になる箇所にテストコードを仕込んで検証する。
  \item パケットアナライザーでやりとりされるデータを確認する（CGIの場合）。
  \item \textbf{パイプで繋がれているコマンド間にteeコマンドを仕込み、そこを流れるデータの途中経過をファイルに書き出して検証する。}
  \item \textbf{シェルスクリプトの実行ログ（set -vx）を取るようにして動作を検証する。}
\end{itemize}
など、ごく普通のものである。ステップ実行をする手段がないくらいであとはIDEと比べても特に遜色は無いと思う。

ごく普通といいながらも、最後の2つはシェルスクリプト独特の手段なので解説しておこう。

\subsubsection*{teeコマンド仕込みデバッグ}

これは、パイプ``\verb!|!''で繋がれたいくつものコマンドでデータを加工していくようなプログラムのデバッグに役立つテクニックだ。

例えば数字のマジックで、「次の計算を行うと答えが必ず1089になるよ」と言われ、
\begin{enumerate}
  \item 好きな3桁の数$a$（ただし数字は3桁とも違うものにする）を思い浮かべる。
  \item その3桁の数$a$の左右を入れ替えた数$b$を作る。
  \item $a$と$b$の差$x$を求める（2桁になったら0埋めして3桁にする）。
  \item その3桁の数$x$の左右を入れ替えた数$y$を作る。
  \item $x$と$y$の和を求めると……
\end{enumerate}
本当かどうか確かめるために次のようなプログラムを組んだとしよう。
\paragraph{数字のマジックを検証するプログラム magic.sh} 　\\
\begin{frameboxit}{160.0mm}
\begin{verbatim}
	#! /bin/sh
	
	# 1) 好きな3桁の数aを引数から受け取る                            #
	echo $1                                                        |
	# 2) その3桁の数aの左右を入れ替えた数bを作る                    #
	awk '{print $1, substr($1,3,1) substr($1,2,1) substr($1,1,1)}' |
	# 3) aとbの差xを求める（3桁に0パディング）                     #
	awk '{printf("%03d\n", $1-$2)}'                                |
	# 4) その3桁の数xの左右を入れ替えた数yを作る                    #
	awk '{print $1, substr($1,3,1) substr($1,2,1) substr($1,1,1)}' |
	# 5) xとyの和を求めると……、必ず1089になるはず                  #
	awk '{print $1+$2}'
\end{verbatim}
\end{frameboxit}
ところが、試しに123という数字を与えたところ、-107という結果が出てきた。
\begin{screen}
	\verb!$ ./magic.sh 123! \return \\
	\verb|-107| \\
	\verb|$ |
\end{screen}
何か間違っている！というわけでデバッグをすることにした。

「パイプを流れるデータを追いかけてみよう」ということで、teeコマンドを各行に挟んだデバッグプログラムを生成し、
\paragraph{数字のマジックを検証するプログラム magic.sh のデバッグ版} 　\\
\begin{frameboxit}{160.0mm}
\begin{verbatim}
	#! /bin/sh
	
	# 1) 好きな3桁の数aを引数から受け取る                            #
	echo $1                                                        | tee step1 |
	# 2) その3桁の数aの左右を入れ替えた数bを作る                    #
	awk '{print $1, substr($1,3,1) substr($1,2,1) substr($1,1,1)}' | tee step2 |
	# 3) aとbの差xを求める（3桁に0パディング）                     #
	awk '{printf("%03d\n", $1-$2)}'                                | tee step3 |
	# 4) その3桁の数xの左右を入れ替えた数yを作る                    #
	awk '{print $1, substr($1,3,1) substr($1,2,1) substr($1,1,1)}' | tee step4 |
	# 5) xとyの和を求めると……、必ず1089になるはず                  #
	awk '{print $1+$2}'
\end{verbatim}
\end{frameboxit}
このプログラムを実行後、step4を見てみたら原因が判明した。
\begin{screen}
	\verb!$ cat step4! \return \\
	\verb|-198 91-| \\
	\verb|$ |
\end{screen}
$a$と$b$の差を求めた際に負の値になったらそれを除去し忘れていたことだった。そこで$a-b$の計算後に負号を取り除くコードを追加したところ。
\paragraph{数字のマジックを検証するプログラム magic.sh のデバッグ版} 　\\
\begin{frameboxit}{160.0mm}
\begin{verbatim}
	#! /bin/sh
	
	# 1) 好きな3桁の数aを引数から受け取る                            #
	echo $1                                                        |
	# 2) その3桁の数aの左右を入れ替えた数bを作る                    #
	awk '{print $1, substr($1,3,1) substr($1,2,1) substr($1,1,1)}' |
	# 3) aとbの差xを求める（3桁に0パディング）                     #
	awk '{printf("%03d\n", $1-$2)}'                                |
	tr -d '-'                                                      | # 追加
	# 4) その3桁の数xの左右を入れ替えた数yを作る                    #
	awk '{print $1, substr($1,3,1) substr($1,2,1) substr($1,1,1)}' |
	# 5) xとyの和を求めると……、必ず1089になるはず                  #
	awk '{print $1+$2}'
\end{verbatim}
\end{frameboxit}
正しく動くようになった。
\begin{screen}
	\verb!$ ./magic.sh 123! \return \\
	\verb|1089| \\
	\verb|$ |
\end{screen}

これがteeコマンド仕込みデバッグである。

\subsubsection*{実行ログ収集デバッグ}

teeコマンドがパイプを流れるデータに注目するデバッグ方法であるのに対し、こちらはシェルスクリプトの動作に注目するデバッグ方法である。具体的にはシェル変数や制御構文（if、for、whileなど）が正しく動作しているを診るのに役立つ。

先程の数字のマジックをシェル変数ベースで書いたプログラム（同様のバグが残っている）があり、デバッグすることになった。このシェルスクリプトではパイプを一切使っていないのでteeコマンド仕込みデバッグが通用しない。
そこで、冒頭の2行にexecとsetのおまじないを書いて実行する。
\paragraph{数字のマジックを検証するプログラム magic2.sh} 　\\
\begin{frameboxit}{160.0mm}
\begin{verbatim}
	#! /bin/sh
	
	# 実行ログを取得
	exec 2>/PATH/TO/logfile.$$.txt # 標準エラー出力の内容をファイルに書き出す
	set -vx                        # 実行ログの標準エラー出力への書き出しを開始する
	# (この行以降のシェルスクリプトの動作が/PATH/TO/logfile.$$.txtに記録される)
	
	a=$1
	b=$(awk "BEGIN{print substr($a,3,1) substr($a,2,1) substr($a,1,1)}")
	x=$(printf '%03d' $((a-b)))
	y=$(awk "BEGIN{print substr($x,3,1) substr($x,2,1) substr($x,1,1)}")
	echo $((x+y))
\end{verbatim}
\end{frameboxit}
実行後に実行ログの中身をみるとこのようになっていた。
\paragraph{シェルスクリプトmagic2.shの実行ログ} 　\\
\begin{frameboxit}{160.0mm}
\begin{verbatim}
	# (この行以降のシェルスクリプトの動作が/PATH/TO/logfile.txtに記録される)

	a=$1
	+ a=123
	b=$(awk "BEGIN{print substr($a,3,1) substr($a,2,1) substr($a,1,1)}")
	awk "BEGIN{print substr($a,3,1) substr($a,2,1) substr($a,1,1)}")
	awk "BEGIN{print substr($a,3,1) substr($a,2,1) substr($a,1,1)}"
	++ awk 'BEGIN{print substr(123,3,1) substr(123,2,1) substr(123,1,1)}'
	+ b=321
	x=$(printf '%03d' $((a-b)))
	printf '%03d' $((a-b)))
	printf '%03d' $((a-b))
	++ printf %03d -198
	+ x=-198
	y=$(awk "BEGIN{print substr($x,3,1) substr($x,2,1) substr($x,1,1)}")
	awk "BEGIN{print substr($x,3,1) substr($x,2,1) substr($x,1,1)}")
	awk "BEGIN{print substr($x,3,1) substr($x,2,1) substr($x,1,1)}"
	++ awk 'BEGIN{print substr(-198,3,1) substr(-198,2,1) substr(-198,1,1)}'
	+ y=91-
	echo $((x+y))
	magic2.sh: line 12: 91-: syntax error: operand expected (error token is "-")
\end{verbatim}
\end{frameboxit}
先頭に``\verb|+|''がない行は、その時点で読み込んだコードやその他標準エラー出力への出力文字列である。
一方``\verb|+|''で始まる行はコードの実行結果である。シェル変数も展開された状態で出力され、どの時点でどのように実行されたが一目でわかる。

この実行ログの最後の行を見ると、magic2.shの12行目で実行時エラーが発生しているのがわかるので、これを手掛かりにデバッグしていくのである。


\subsection*{解説}

\subsubsection*{teeコマンドについて}

teeコマンドの由来は、T字型のパイプである。T字型のパイプは、入ってきた流体が2方向に分岐する。
teeコマンドはこれと同様に、標準入力から入ってきたデータを一方はそのまま標準出力に送り、もう一方は引数で指定されたファイルに送る。
（ただし本物のT字型パイプと違ってデータ量は半減しない）

これはUNIXにおいて、パイプという仕組みと並んで偉大な発明品だと思う。

\subsubsection*{setコマンドの-vと-xオプションについて}

シェルの内部コマンドsetにおけるこれら2つのオプションは、まさにデバッグのために存在するといっても過言ではないのではなかろうか。

先程示した実際の実行ログを見ればわかるように、``\verb|-v|''オプションは読み込んだシェルスクリプトのコードをそのまま標準エラー出力へ送るもの、
``\verb|-x|''オプションは実行したコード文字列を（シェル変数を展開しながら）標準エラー出力へ送るものである。
シェルにはステップ実行をしてくれる機能は無いが、実行経過を各行ログに書き出してくれるのは様々な言語を見渡しても珍しい機能ではないだろうか。

ちなみにシェルスクリプトの途中で
\begin{verbatim}
	set +vx
\end{verbatim}
と書けば、その行以降は実行ログに出力されないし、併せて
\begin{verbatim}
	exec 2>/dev/stderr
\end{verbatim}
と書けば本来の標準エラー出力に戻る\footnote{ファイルディスクリプターを熟知しているのであれば、冒頭で\verb|exec 3>&2 2>logfile|などと書いて本来の標準エラー出力を別のファイルディスクリプターに退避させておき、最後に\verb|exec 2>&3 3&-|とやるのが望ましい。}。


\subsubsection*{実行ログを恒久的に残すか}

実行ログはデバッグのために紹介したが、私はデバッグ作業の時のみならず、リリース後も日頃から実行ログを取り、恒久的に残すようにしている。
だが、その是非を巡っては2つの意見が対立する。

\paragraph{恒久的に残す利点}
最大の利点は、緊急事態に陥った時でも、素早く平常を取り戻すのに役立つ点にある。

例えば、作ったプログラムに100万回に1度の割合で起こるバグが潜んでいたとしよう。
しかし一度起こると大損害をもたらす最悪のバグだっとする。

ある日そのバグが発生してしまったために、血眼なってデバッグする羽目になった。
ところが、実行ログをとっていなかったので何も手がかりがない！再現するにも100万回に一度の現象などそう簡単には起こらない。
一体、このデバッグ地獄は作業はいつ終わるんだろうか……。恒久的に実行ログを残しておけばこうした地獄を見ずに済む。実行ログも「ログ」の一種であり、ログとは本来そういう目的のものである。

現実世界というのは、いくら自分が正しいプログラムを書いていても、外部システムやハードウェア、あるいは人為的な問題により想定外の事故が起こる。実行ログの恒久的保存という発想も、こういう事態に散々泣かされてきたからこそ、生まれたものである。

\paragraph{恒久的に残す危険性}
実行ログ保存の恩恵の裏には2つの脅威がある。

1つはログファイルによるディスク空き領域の圧迫である。
1回のWebアクセスで1行〜数行程度のWebアクセスログの成長に比べると実行ログの成長速度は何百倍にもなる。
従って、異常な頻度でアクセスを受ければディスク空き領域が食い尽くされてサービス不能に陥る恐れがあるということだ。

もう1つは機密情報の漏洩である。実行ログには動作中のあらゆる情報が残る。先程示したように、シェル変数の内容は丸見えだ。
例えばログイン認証のCGIスクリプトであれば、クライアントから送られてきたID,パスワードが平文で残ってしまう。
無関係な人にそのログファイルを開かれてしまったらあなたのプログラマーとしての信用は地に墜ちるだろう。

\paragraph{あるセキュリティー専門家のアドバイス}
ディスク空き領域の圧迫に対する対策は容易だ。残量が一定以下であることを検出したらログ収集を中止したり、過去のものから削除するようにプログラムを組めばよい。
より深い問題は、情報漏洩対策だ。

この問題に対し、私はセキュリティー専門家から
\begin{quotation}
	\noindent
	ログファイルにgzip等で圧縮を掛けて保存するだけでも効果があります。
\end{quotation}
とアドバイスを受けた。

悪意ある人間は知能をもっており、そういう相手からログファイルを守るのは確かに困難だ。
しかし、手当たり次第に情報を暴露しようとするマルウェアに侵される可能性の方がよほど高く、
それらには知能が低く、大抵バイナリーファイルはバイナリーのまま暴露するため、途中で壊れる可能性が高いからだという。
もちろん、将来マルウェアの知能が上がったら暗号化の検討も必要であろうが、確かに現状での妥協点だと思った。

そこで私は、zpipeというコマンドを作った\footnote{\verb|https://github.com/ShellShoccar-jpn/misc-tools/blob/master/zpipe|}。
これはコマンド呼び出し元のプロセスが生存している間だけ存在するような、名前付きパイプを作る（=mkfifoする）コマンドで、
その名前付きパイプの先には圧縮コマンド（compress）が待ち構え、随時圧縮しながらファイルに書き落とすという仕組みだ。

使い方はつぎのとおり。
\paragraph{zpipeコマンドを使った圧縮実行ログ取得方法} 　\\
\begin{frameboxit}{160.0mm}
\begin{verbatim}
	#! /bin/sh
	
	# 実行ログを取得
	# zpipe: 第1引数=作りたい名前付きパイプのパス
	#        第2引数=最終的に書き落としたいファイルのパス
	zpipe /PATH/TO/named_pipe /PATH/TO/logfile.$$.txt.Z
	[ $? -eq 0 ] || exit 1              # zpipeに失敗したら中断
	exec 2>/PATH/TO/named_pipe          # 今作った名前付きパイプに書き込ませる
	set -vx                             # 走行ログ取得開始

	# 以降の内容が実行ログに記録される
	   :
	   :
	（zpipeを実行したプログラムが終了したら、named_pipeは自動消滅する）
\end{verbatim}
\end{frameboxit}
もちろん平文の実行ログを作った後で、cronでまとめて圧縮するシェルスクリプトを作ってもよいのだが。
このコマンドを使えば平文での生存期間をゼロにすることが可能である。
