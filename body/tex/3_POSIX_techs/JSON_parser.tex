\section{JSONファイルを読み込む}
\label{recipe:JSON_parser}

\subsection*{問題}
\noindent
$\!\!\!\!\!$
\begin{grshfboxit}{160.0mm}
	Web APIを叩いて得られたJSONファイルの任意の箇所の値を読み出したい。
	しかし、先程解説されたCSVファイルの比ではなく構造が複雑だ。
	それでもできるのか？
\end{grshfboxit}

\subsection*{回答}
JSONであってもsedやAWKを駆使すれば、やはりPOSIXの範囲でパーサーが作れる。
解説は後回しにして、制作したJSONパーサー``parsrj.sh''をダウンロード\footnote{\verb|https://github.com/ShellShoccar-jpn/Parsrs/blob/master/parsrj.sh|にアクセスし、そこにあるソースコードをコピー\&{}ペーストしてもよいし、あるいは``RAW''と書かれているリンク先を「名前を付けて保存」してもよい。}して使ってもらいたい。

例えば、次のようなCSVファイル（sample.json）があったとする。\\
\begin{frameboxit}{160.0mm}
\begin{verbatim}
	{"会員名" : "文具 太郎",
	 "購入品" : [ "はさみ",
	              "ノート(A4,無地)",
	              "シャープペンシル",
	              {"取寄商品" : "替え芯"},
	              "クリアファイル",
	              {"取寄商品" : "6穴パンチ"}
	            ]
	}
\end{verbatim}
\end{frameboxit}

これを次のようにしてparsrj.shに掛けると、
第1列:元の値のあった場所（JSONPath形式\footnote{JSONデータは階層構造になっているので、同様に階層構造をとるファイルパスのようにして一行で書き表せる。その記法がJSONPathである。詳細は\verb|http://goessner.net/articles/JsonPath/|参照。}）、第2列:値、
という2つの列から構成されるテキストデータに変換される。
\begin{screen}
	\verb|$ ./parsrj.sh sample.json| \return \\
	\verb|$.会員名 文具 太郎| \\
	\verb|$.購入品[0] はさみ| \\
	\verb|$.購入品[1] ノート(A4,無地)| \\
	\verb|$.購入品[2] シャープペンシル| \\
	\verb|$.購入品[3].取寄商品 替え芯| \\
	\verb|$.購入品[4] クリアファイル| \\
	\verb|$.購入品[5].取寄商品 6穴パンチ| \\
	\verb|$ |
\end{screen}

よって、後ろにパイプ越しにコマンドを繋げば「任意の場所の値を取得」ができる。例えば次のような具合だ。
\begin{screen}
	(a) 購入品の2番目（番号1）を取得する \\
	\verb!$ ./parsrj.sh sample.json | grep '^\$\.購入品\[1\]' | sed 's/^[^ ]* //'! \return \\
	\verb|ノート(A4,無地)| \\
	\verb|$ | \\
	\\
	(b) 全ての取寄商品名を抽出 \\
	\verb!$ ./parsrj.sh sample.json | awk '$1~/取寄商品$/' | sed 's/^[^ ]* //'! \return \\
	\verb|替え芯| \\
	\verb|6穴パンチ| \\
	\verb|$ |
\end{screen}

\subsubsection*{JSONにエスケープ文字が混ざっている場合}

JSONは、コントロールコードや時にはマルチバイト文字をエスケープして格納している事がある。例えば``\verb|\t|''や``\verb|\n|''はそれぞれタブと改行文字であるし、``\verb|\uXXXX|''（XXXXは4桁の16進数）はUnicode文字である。このような文字を元に戻すフィルターコマンド``unescj.sh''も同じ場所にリリースした\footnote{\verb|https://github.com/ShellShoccar-jpn/Parsrs/blob/master/unescj.sh|}。

詳細な説明はparsrj.shとunescj.shのソースコード冒頭に記したコメントを見てもらうことにして割愛するが、parsrj.shで解読したテキストファイルをパイプ越しにunescj.shに与えれば解読してくれる。もちろんunescj.shもPOSIXの範囲で書かれている。

\subsection*{解説}

CSVがパースできたのと同様に、JSONのパースもPOSIXの範囲でできる。本章の冒頭で述べたことだが、POSIXに含まれるsedやAWKはチューリングマシンの要件を満たしているのだから、それらを使えば理論的にも可能なのだ。CSVの時と同様、JSONにも値の位置を示すための記号と、同じ文字ではあるものの純粋な値としての記号があるが、冷静に手順を考えればきちんと区別・解読することができるのだ。とは言うものの具体的にどのようにして実現したのかを解説するのは大変なので、どうしても知りたい人はparsrj.shのソースコード読んでもらうことにして、ここでの説明は割愛する。

しかし、JSONパーサーとしては``jq''という有名なコマンドが既に存在する。にもかかわらず、私はなぜ再発明したのか。確かに、拙作のコマンドならPOSIX原理主義に基づいているため、「どこでも動く」「10年後も20年後も、たぶん動く」「コピー一発デプロイ完了」の三拍子が揃っているという利点もあるのだが、真の理由はまた別のところにあるので、ここで語っておきたい。この後のレシピでXMLパーサーを作った話を述べるが、同様の理由であるのでまとめて語ることにする。

\subsection*{JSON \& XMLパーサーという「車輪の再発明」の理由}

\subsubsection*{jqやxmllint等、UNIX哲学に染まりきっていない}

シェルスクリプトで、JSONを処理したいといったらjqコマンド、XMLを処理したいといったらxmllintやhxselect（html-xml-utilsというユーティリティーの1コマンド）、あるいはMacOS Xのxpathといったコマンドを思い浮かべるかもしれない。そして、それらは「便利だ」という声をちらほら聞くのだが、私はちっとも便利に思えない。試しに使ってみても「なぜこれで満足できる？」とさえ思う。理由はこうだ。

\paragraph{理由1. 一つのことをうまくやっていない}　\\
UNIX哲学の一つとしてよく引用されるマイク・ガンカーズの提唱する定理に
\begin{description}
  \item[定理1.] 小さいものは美しい。
  \item[定理2.] 1つのプログラムには1つのことをうまくやらせよ。
\end{description}
というものがある。しかし、まずこれができていない。jqやxmllint等は、データの正規化(都合の良い形式に変換する)機能とデータの欲しい部分だけを抽出する部分抽出機能を分けていない。むしろ前者をすっ飛ばして後者だけやっているように思う。

でもUNIX使いとしては、\textbf{部分抽出といったらgrepやAWK}を使い慣れているわけで、それらでできるようにしてもらいたいと思う。部分抽出をするために、\textbf{jqやxmllint等独自の文法をわざわざ覚えたくない}し。

だから、正規化だけをやるようなコマンドであってほしかった。

\paragraph{理由2. フィルターとして振る舞うようになりきれてない}　\\
同じく定理の一つに
\begin{description}
  \item[定理9.] 全てのプログラムはフィルターとして振る舞うように作れ。
\end{description}
というものがある。フィルターとは、入力されたものに何らかの加工を施して出力するものをいうが、jqやxmllint等は、出力の部分に注目するとフィルターと呼ぶには心もとない気がする。

なぜなら、これらのプログラムはどれも\textbf{JSONやXML形式のまま出力}される。しかし、他の標準UNIXコマンドからは扱いづらい。AWK,sed,grep,sort,head,tail,……などなど、\textbf{標準UNIXコマンドの多くは、行単位あるいは列単位(スペース区切り)のデータを加工するのに向いた仕様}になっているため、JSONやXML形式のままだと結局扱いづらい。

だから、行や列の形に正規化するコマンドであってほしかった。

\subsubsection*{無いものは作る。UNIXコマンドとパイプを駆使して。}

そうして作ったパーサーが、このレシピやそしてこの後の\ref{recipe:XML_parser}で紹介したものだ。GitHubに置いてあるソースコード\footnote{\verb|https://github.com/ShellShoccar-jpn/Parsrs|}を見れば明白だが、これらのパーサーもまた、シェルスクリプトを用い、AWK、sed、grep、tr等をパイプで繋ぐだけで実装した。

これまたUNIX哲学の定理だが、
\begin{description}
  \item[定理6.] ソフトウェアは「てこ」。最小の労力で最大の効果を得よ。
  \item[定理7.] 効率と移植性を高めるため、シェルスクリプトを活用せよ。
\end{description}
というものがある。その定理に従って実際に作ってみると、シェルスクリプトやUNIXコマンド、パイプというものがいかに偉大な発明であるか思い知らされた。

無ければ自分で作る。由緒正しいUNIXの教本にも、「置いてあるコマンドは見本みたいなものだから、無いものは自分達で作りなさい」と書かれているそうだ。それに、自分で作れば、対象概念の理解促進にもつながる。

\subsection*{参照}

\noindent
→\ref{recipe:CSV_parser}（CSVファイルを読み込む） \\
→\ref{recipe:XML_parser}（XML、HTMLファイルを読み込む）
