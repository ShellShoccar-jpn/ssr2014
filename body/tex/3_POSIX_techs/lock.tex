\section{ロック（排他・共有）とセマフォ}
\label{recipe:lock}

\subsection*{問題}
\noindent
$\!\!\!\!\!$
\begin{grshfboxit}{160.0mm}
	プログラムを書いていると、
	\begin{enumerate}
	  \item 複数プロセスから同時にファイルを読み書きされたくない（排他ロックがやりたい）
	  \item 同時読み込みはいいが、その間書き込みはされたくない（共有ロックがやりたい）
	  \item CPUコア数までしか同時にプロセスを立ち上げたくない（セマフォがやりたい）
	\end{enumerate}
	ということがよくあるが、シェルスクリプトだとこれらができないので他言語に頼らざるを得ない。それでもPOSIX原理主義を貫けと言うのか？
\end{grshfboxit}

\subsection*{回答}
大丈夫、できる。確かにPOSIXの範囲にはロックやセマフォを直接実現するコマンドが存在しない。しかし、1つのディレクトリーには同じ名前のファイルが作れないというファイルシステムの基本的性質を活用し、早い者勝ちでファイルを作れたプロセスにアクセス権を与えるというルールを設け、さらにいくつかのアイデアを凝らせば全て実現可能だ。（詳細は解説で述べる）

ただ、いくらできるといっても毎回書くに大変な量ので、一発でできるコマンドを作ったからこれを使うとよい。まずは次のものをダウンロードしてパスを通しておく。
\begin{table}[H]
  \caption{ロック・セマフォ関連コマンド}
  \begin{center}
  \begin{tabular}{l!{\VLINE}>{\PBS\raggedright}m{37zw}}
    \HLINE
         目的                   & コマンドのダウンロード場所                                                \\
    \hline
    \hline
         排他ロック             & \verb|https://github.com/ShellShoccar-jpn/misc-tools/blob/master/pexlock| \\
    \hline
         共有ロック             & \verb|https://github.com/ShellShoccar-jpn/misc-tools/blob/master/pshlock| \\
    \hline
         セマフォ               & （上記の共有ロック用コマンドを用いる）                                    \\
    \hline
         ロック・セマフォ解除   & \verb|https://github.com/ShellShoccar-jpn/misc-tools/blob/master/punlock| \\
    \hline
         解除漏れファイルの清掃 & \verb|https://github.com/ShellShoccar-jpn/misc-tools/blob/master/pcllock| \\
    \HLINE
  \end{tabular}
  \label{tbl:command_for_sendjpmail}
  \end{center}
\end{table}

ロック・セマフォの実現にはファイルを活用すると述べたが、そのファイルを作るための「ロック管理ディレクトリー」を用意する。ここでは便宜的に\verb|/PATH/TO/LOCKDIR|であるものとする。

\subsubsection*{排他ロック}

例えば、ある会員データファイル（\verb|/PATH/TO/MEMBERS_DB|）を編集するプログラムがあって、他のプロセスが編集・あるいは照会していない隙に安全に読み書きできるようにするには、次のようなコードを書けばよい。\\
\begin{frameboxit}{160.0mm}
\begin{verbatim}
	         ：
	         ：
	# "members_db"というロックIDで排他ロック権を獲得する
	# (成功するまで最大10秒待つ)
	lockinst=$(pexlock -w 10 -d /PATH/TO/LOCKDIR members_db)
	if [ $? -ne 0 ]; then
	  echo '*** failed to lock "MEMBERS_DB"' 1>&2
	  exit 1
	fi
	
	↑
	排他ロック区間（ここで"/PATH/TO/MEMBERS_DB"を読み書きしてよい）
	↓

	# 排他ロック権を解放する（先程得たロックインスタンス"$lockinst"を指定する）
	punlock "$lockinst"
	         ：
	         ：
\end{verbatim}
\end{frameboxit}
このコードは、次に紹介する共有ロックプログラムと一緒に使うことができる（pexlockとpshlockは互いを尊重する）。

\subsubsection*{共有ロック}
例えば、ある会員名簿ファイル（\verb|/PATH/TO/MEMBERS_DB|）の内容を照会するプログラムがあって、他のプロセスが編集していない隙（読み出しているプロセスはいてもいい）に安全に読み出せるようにするには、次のようなコードを書けばよい。\\
\begin{frameboxit}{160.0mm}
\begin{verbatim}
	         ：
	         ：
	# "members_db"というロックIDで共有ロック権を獲得する
	# (成功するまで最大10秒待つ)
	lockinst=$(pshlock -w 10 -d /PATH/TO/LOCKDIR stock_db)
	if [ $? -ne 0 ]; then
	  echo '*** failed to lock "STOCK_DB"' 1>&2
	  exit 1
	fi
	
	↑
	共有ロック区間（ここで"/PATH/TO/MEMBERS_DB"を読み込んでよい）
	↓

	# 共有ロック権を解放する（先程得たロックインスタンス"$lockinst"を指定する）
	punlock "$lockinst"
	         ：
	         ：
\end{verbatim}
\end{frameboxit}
このコードは、先程紹介した排他ロックプログラムと一緒に使うことができる（pexlockとpshlockは互いを尊重する）。

\subsubsection*{セマフォ}
例えば、CPUに高い負荷を掛けるプログラム（\verb|heavy_work.sh|）があり、これを8コアのCPUを搭載しているホストで動かすため、同時起動を最大8プロセスに制限したい場合には、次のようなコードを書けばよい。\\
\begin{frameboxit}{160.0mm}
\begin{verbatim}
	         ：
	         ：
	# "heavy_task"というロックIDで、最大同時アクセス数8のセマフォを取得する
	# (成功するまで最大10秒待つ)
	seminst=$(pshlock -n 8 -w 10 -d /PATH/TO/LOCKDIR heavy_task)
	if [ $? -ne 0 ]; then
	  echo '*** failed to get a semaphore for "heavy_task"' 1>&2
	  exit 1
	fi
	
	# ここで、高負荷プログラムを実行する
	heavy_work.sh
	
	# 終わったらセマフォを返却する（先程得たセマフォインスタンス"$seminst"を指定する）
	punlock "$lockinst"
	         ：
	         ：
\end{verbatim}
\end{frameboxit}

\subsubsection*{ロック・セマフォ解除漏れへの対策}
今紹介した各プログラムに強制終了の恐れがあったり、バグによって解除忘れがあると他のプログラムがロック権を獲得できなくなってしまう。そのような場合には、定期的にロック管理ディレクトリーをスキャンし、一定の時間が経った古いロックファイル（かつ持ち主のプロセスが既に存在しない）を削除する必要がある。

これを行うためのコマンドがpcllockであり、例えばcrontabに次のように登録して使う。
\paragraph{前記のロック・セマフォプログラムを実行しているユーザーのcrontabファイル}　\\
\begin{frameboxit}{160.0mm}
\begin{verbatim}
	         ：
	         ：
	# 5分(=300秒)以上経ち、かつ生成元プロセスが既にいないロックファイルを毎分監視
	* * * * * pcllock -l 300 -w 10 /PATH/TO/LOCKDIR
\end{verbatim}
\end{frameboxit}

\subsection*{解説}

シェルスクリプトでロックやセマフォを実現するための原理は、1つのディレクトリーには同じ名前のファイルが作れないという性質の活用であることは既に述べた。それを聞いて「なんとベタな方法なのか！」と落胆するかもしれないが、侮ることなかれ。もともとOSは、物理的に1台しかないディスクへのアクセス要求を捌くため、内部で必ず排他制御をやっている。従って\textbf{ファイルによるロック管理とは、OSが備えている洗練された排他制御機構の活用}に他ならないのだ。

だが、それでは排他ロックの説明にしかなっていない。共有ロック、セマフォまで含めて、どうやって実現しているのかを解説しよう。まずはこの後の説明のため、2つの基本ルールを確認しておく必要がある。

\subsubsection*{基本ルール1. ロックファイルを作れた者勝ち}
早い者勝ちでロックファイルを作るというルールの詳細は次のとおりとする。
\begin{itemize}
  \item 早い者勝ちでファイル（ロックファイル）を作る。
  \item 「成功者はロック成功（アクセス権取得）」と取り決める。
  \item 失敗者は暫くしてから再度ロックファイル作成を試みる。
  \item 成功者は用事が済んだらロックファイル消す。
\end{itemize}
これを基本ルール1として制定する。

\subsubsection*{基本ルール2. 一定の時間が経った古いロックファイルは消してよい}
実際は、成功者がロックをしたまま消し忘れたり、何らかの理由で異常終了してしまうとアクセス権が紛失されてしまうという問題がある。仕方が無いので、ロックファイルのタイムスタンプを確認し、\textbf{一定以上古いロックファイルは消してよい}という基本ルール2を制定する。ただ、可能ならば生成元のプロセスが既に存在しないことも確認する方が親切だ。

ただし、重大な注意点が1つある。
\begin{quotation}
	\noindent
	一定以上古いロックファイルを消すという役割は、1つのロック管理ディレクトリーに対して1つのプロセスにしか与えてはならない。
\end{quotation}
ということだ。もし、あるプロセスAが一定以上古いロックファイル検出し、今からそれを消して新たに作り直そうとしている時、プロセスBが同じロックファイルを古いと判断して削除し、新規作成まで済ませてしまったらどうなるか。プロセスAはこの後、プロセスBの作ったロックファイルを誤って消してしまうことになる。これは、古いファイルの検出、削除、作り直しという操作が、アトミックに（単一操作で）できないという制約に起因する。よって、古いロックファイルの削除役は一人でなければならないのである。

尚、ここで出てきた「一定以上古いファイルを検出する」という処理がPOSIXの範囲では面倒なのだが、これに関しては\ref{recipe:timestamp}（findコマンドで秒単位にタイムスタンプ比較をする）を利用すれば解決できるので、ここでは割愛する。

以上を踏まえ、各ロックを実現するアイデアをまとめる。

\subsubsection*{その1. 排他ロックはどうやるか}
排他ロックとは、誰にも邪魔されない唯一のアクセス権を獲得するためのロックだ。ファイルを読み書きする場合などに用いる。

ファイルを用いて排他ロックを実現する方法というのは実はよく知られており、単純である。ロック管理用ディレクトリーの中でロックファイルを作ればよいわけだが、既存ファイルがある場合にはロックファイル作成が失敗するようにして作成するには例えば次の方法がある。
\begin{itemize}
  \item \verb|mkdir |\textit{ロックファイル}
  \item \verb|ln -s |\textit{ダミーファイル} \textit{ロックファイル}
  \item \verb|ln |\textit{ダミーファイル} \textit{ロックファイル}
  \item \verb|(set -C; : > |\textit{ロックファイル}\verb|)|
\end{itemize}
ポイントは、アトミックに（単一操作で）作るという点である。つまり存在確認処理と作成処理が同時ということだ。もしこれから作りたい名前のファイルが存在しないことを確認できて、いざ作成しようとした時に他のプロセスに素早く作成されてしまったら、ロックファイルを上書きできてしまうのでアクセス権が唯一のものではなくなってしまう。

排他ロックコマンドpexlockでは、今列挙した4つのうち最後の方法を用いている。後で紹介する共有ロックコマンドでは複数のアクセス権を管理するためにディレクトリー（mkdir）を用いており、それと区別させるためだ。

\subsubsection*{その2. 共有ロック・セマフォはどうやるか}
共有ロックとは、そのロックを申請した全てのプロセスでアクセス権を共有するためのロックだ。自分がファイルを読み込んでいる間、他のプロセスもそれを読み込むだけなら許すが、書き込み許さない、というプロセス同士がアクセス権を共有したい場合などに用いる。

一方セマフォとは、共有ロックの最大共有数を制限するロックだ。物理デバイスの数だけプロセスを同時に走らせたい場合などに用いる。セマフォは共有ロックの応用で実現できるため、ここでまとめて説明する。

排他ロックファイルに比べるとだいぶ複雑であるが、まず共有ロックファイル（ディレクトリー）には次の構造を持たせることとする。\paragraph{pshlockが扱う共有ロックファイル（HOGEという名前とする）の構造}　\\
\begin{frameboxit}{160.0mm}
\begin{verbatim}
	LOCKDIR/           ← ロックファイル管理ディレクトリー
	|
	+-HOGE/            ← ロックファイル一式（親ディレクトリー）
	  |
	  +-HOGE/          ← ロックファイル一式（同名の子ディレクトリー）
	    |                 ・このディレクトリーのハードリンク数-2が共有数
	    |
	    +-uniq_num1.pid1/ ← 共有ロックをかける度に作成するサブロック名
	    +-uniq_num2.pid2/    (一意な番号+呼出元プロセスID)
	    :
	    |
	    + modifying  ← 上記のサブロック名ディレクトリーを追加削除する際の
	                   アクセス権のための排他ロックファイル（作業時のみ存在）
\end{verbatim}
\end{frameboxit}
これにはいくつか工夫が凝らしてある。
\paragraph{同名で二重化されたディレクトリー}
なぜ同名のディレクトリーを二重に作っているのか。これは共有ロックファイル（ディレクトリー）をアトミックに作るための巧妙な仕掛けである。

後で改めて説明するが、共有ロックディレクトリーの中には、共有中のプロセスによって一意に作られたディレクトリー（サブロックディレクトリー）が必ず存在しなければならない。現在共有中のプロセス数を示すためである。それゆえ、もし何も考えず本番のロック管理ディレクトリーに直接に新規作成してしまうと、作成した瞬間の共有ロックディレクトリーは空であるため、共有プロセス数が0（もはや誰も共有していない）と見なされて削除される恐れがある。よって本番のロック管理ディレクトリーに直接作ることは避けなければならない。

そこで、予め別の安全な場所でサブロックディレクトリーまで中身を作っておき、mvコマンドを用いて本番ディレクトリーに移動させる。ところがもし移動先に既存の共有ロックディレクトリーがあると通常\textbf{mvコマンドは、その共有ロックディレクトリーのサブディレクトリーとして移動を成功させてしまう。}共有ロックディレクトリーの直下にわざわざ同名のディレクトリーを置くのはこの問題への対策である。同名のディレクトリーが直下にあれば、mvコマンドも移動を諦めてくれる。
\paragraph{中に\textit{$<$固有番号+ロック要求プロセスID$>$}のディレクトリーを作る}
これもまた巧妙な仕掛けだ。先程説明した二階層同名ロックディレクトリーの下層側（子）に、共有ロックを希望する各プロセスがさらに1つディレクトリーを作る。この際、ディレクトリー名が衝突しないように\textit{$<$固有番号+ロック要求プロセスID$>$}という命名規則（固有番号は、作成日時とpshlockコマンドプロセスIDに基づいて作ればよい）による一意な名称（サブロック名）を付ける。

目的は先程も述べたが、現在の共有プロセス数を把握するためである。共有数が把握できれば後述するセマフォ（共有数に制限を設ける）を実現できるし、また共有数0になった際に共有ロックディレクトリー自体を削除するという判断もできる。

では具体的にどうやって共有数を把握するか? 中に作成したディレクトリー数を素直に数えるという方法もあるが、もっと軽い方法がある。共有ロックディレクトリー（子）のハードリンク数を見るという方法だ。
\begin{quotation}
	\noindent
	\verb|ls -ld |\textbf{共有ロックディレクトリー（子）}
\end{quotation}
を実行した時、2列目に表示される数字がそれである。この数字から2を引くと、直下のサブディレクトリーの数になる\footnote{ディレクトリーを作成すると、必ず自分自身を示す``\verb|.|''と、親ディレクトリーを示す``\verb|..|''が作成される。これらこそが数字を2つ大きく見せている原因であって、今作ったディレクトリーに対するハードリンクなのである。}。従って上記のコマンドで2列目の数を取得すれば、いちいち全部数えずとも、共有数を計算できるのである。
\paragraph{共有数を増減・参照する際は、更に排他ロック}
\begin{itemize}
  \item 共有数が0だったら共有ロックディレクトリーを削除する。
  \item 共有数が上限に達したらそれ以上の共有を拒否する（セマフォ制御）。
\end{itemize}
といった操作は、どうしてもアトミックに行うことができない。共有数を調べて処理を決めようとしている時に共有数が変化してしまう恐れがあるからだ。これを防ぐため、共有数を参照する時と共有数を増減させる時は、そこで更に排他ロックを掛けなければならない。

共有数を参照したい場合は今列挙したとおりだが、増減させたい時というのは次の場合である。
\begin{itemize}
  \item 共有ロックを追加したい場合
  \item 共有ロックを削除したい場合
  \item 共有ロックディレクトリー（子）内のサブロック名ディレクトリーのうち古いものを、基本ルール2に従って一斉削除したい場合
\end{itemize}
以上、列挙した操作を行う場合に作る排他ロックファイルが
\begin{quotation}
	\noindent
	\textbf{共有ロックディレクトリー（子）}\verb|/modifying|
\end{quotation}
というファイルである。

\subsubsection*{共有ロック・セマフォの実装のまとめ}
以上の理屈に基づいてコードに起こしてみたものをいくつか例示する。実際のコードには異常系の処理等があり、これより込み入っているが、わかりやすくするためにそれらは書いていない。

\paragraph{共有ロックファイル新規作成}
まずは共有ロックファイル新規作成のコードを見てみよう。安全な場所で共有ロックディレクトリーを作成し、本番ディレクトリーにmvコマンドで移動している。もしmvに失敗した場合は、共有ロックディレクトリーが既に存在していることを意味しているので、次に例示するシェル関数add\_{}shlock()へ進む。\\
\begin{frameboxit}{160.0mm}
\begin{verbatim}
	LOCKDIR="/PATH/TO/LOCKDIR" # ロックの管理を行うディレクトリー
	lockname="ロック名"        # 共有ロック名
	MAX_SHARING_PROCS=上限数   # セマフォモードの場合に使う上限数

	# 安全な場所で共有ロックファイルを新規作成
	callerpid=$(ps -o pid,ppid | awk '$2=='$$'{print $1;exit}')
	sublockname=$(date +%Y%m%d%H%M%S).$$.$callerpid
	tmpdir="$LOCKDIR/.preshlock.$sublockname"
	shlockdir_pre="$tmpdir/$lockname/$lockname/$sublockname"
	mkdir -p $shlockdir_pre

	# 本番ディレクトリーへの移動を試みる
	try=3 # リトライ数
	while [ $try -gt 0 ]; do
	  # mvに成功したら新規作成成功
	  mv $shlockdir_pre $LOCKDIR 2>/dev/null && {
	    echo "$LOCKDIR/$lockname/$lockname/$sublockname" # 後で削除できるよう、
	    break                                            # サブロック名ファイルパスを返す
	  }

	  # 失敗したら追加作成モードで試みる
	  add_shlock && break  # add_shlock()の中身は別途説明

	  try=$((try-1))
	  [ $try -gt 0 ] && sleep 1                          # リトライする場合は1秒待つ
	done
	case $try in 0) echo "timeout, try again later";exit 1;; esac

	# 安全な場所として作ったディレクトリーを削除
	rm -rf "$tmpdir"
\end{verbatim}
\end{frameboxit}

尚、「安全な場所」を確保するためにロックファイルディレクトリーの中に``\verb|.preshlock.|\textit{サブロック名}''という一意なディレクトリーを作っている。そのため、\verb|^\.preshlock\.[0-9.]+$|という正規表現に該当するロック名は予約名として使用禁止とする。

\paragraph{共有ロックファイル（ディレクトリー）追加作成}
前記のコードで共有ロックディレクトリーの新規作成に失敗した場合には次に記すシェル関数add\_{}shlock()が呼び出される。

共有数を増減・参照するのでまず排他ロックファイルmodifyingを作り、共有数が上限に達していないか調べ、達していなければサブロック名ディレクトリーを1つ作る。最後に排他ロックファイルを消すのも忘れぬようにする。\\
\begin{frameboxit}{160.0mm}
\begin{verbatim}
	add_shlock() {
	  # 共有数アクセス権取得（失敗したらシェル関数終了）
	  (set -C; : >$LOCKDIR/$lockname/$lockname/modifying) || return 1

	  # 共有数（=共有ロックファイル(子)の数-2）が制限を超えていないか
	  # ※ この処理はセマフォ制御の場合のみ
	  n=$(ls -dl $LOCKDIR/$lockname/$lockname | awk '{$2-2}')
	  [ $n -ge $MAX_SHARING_PROCS ] || return 1 # 超過時は関数終了

	  # 共有ロック追加
	  sublockname=$(date +%Y%m%d%H%M%S).$$.$callerpid
	  mkdir $tmpdir/$lockname/$lockname/$sublockname
	  echo "$LOCKDIR/$lockname/$lockname/$sublockname" # 後で削除できるよう、
	                                                   # サブロック名パスを返す
	  # 共有数アクセス権解放
	  rm $LOCKDIR/$lockname/$lockname/modifying
	}
\end{verbatim}
\end{frameboxit}

\paragraph{共有ロックファイル（ディレクトリー）削除}
自分で作った共有ロックを削除する場合は、ロック成功時に渡されたロックファイル（サブロック名まで含む）のフルパスを渡す。それに基づいてサブロック名ディレクトリーを削除、更に古いディレクトリーも削除した結果、共有数0になっていたら共有ロックディレクトリーごと削除する。\\
\begin{frameboxit}{160.0mm}
\begin{verbatim}
	lockfile="ここにロックファイル名（サブロック名まで含む）"

	try=3 # リトライ数
	while [ $try -gt 0 ]; do
	  # 共有数アクセス権取得
	  (set -C; : >${lockfile#/*}/modifying) && break

	  try=$((try-1))
	  [ $try -gt 0 ] && sleep 1
	done
	case $try in 0) echo "timeout, try again later";exit 1;; esac

	# ロック解除対象のサブロック名ディレクトリーを削除
	rmdir $lockfile

	# 共有数（=共有ロックファイル(子)の数-2）が0なら共有ロックdir自身を削除
	n=$(ls -dl ${lockfile#/*} | awk '{$2-2}')
	if [ $n -le 0 ]; then
	  rm -rf ${lockfile#/*}/..
	else
	  # 共有数が0でなければ、共有数アクセス権を解放するのみ
	  rm ${lockfile#/*}/modifying
	fi
\end{verbatim}
\end{frameboxit}


\subsection*{参照}

\noindent
→\ref{recipe:timestamp}（findコマンドで秒単位にタイムスタンプ比較をする）
