\section{CSVファイルを読み込む}
\label{recipe:CSV_parser}

\subsection*{問題}
\noindent
$\!\!\!\!\!$
\begin{grshfboxit}{160.0mm}
	ExcelからエクスポートしたCSVファイルの任意の行の任意の列を読み出したい。
	しかし実際読み出すとなったら、列区切りとしてカンマと値としてのカンマを区別しなければいけなかったり、
	行区切りとしての改行と値としての改行を区別しなければいけなかったり、
	さらに値としてのカンマや改行を区別するためのダブルクォーテーション記号を意識しなければいけなかったり、
	大変だ。
\end{grshfboxit}

\subsection*{回答}
sedやAWKを駆使すればPOSIXの範囲でパーサー（解析プログラム）の作成が可能である。
原理の解説は後回しにするが、そうやって制作したCSVパーサー``parsrc.sh''があるので、それをダウンロード\footnote{\verb|https://github.com/ShellShoccar-jpn/Parsrs/blob/master/parsrc.sh|にアクセスし、そこにあるソースコードをコピー\&{}ペーストしてもよいし、あるいは``RAW''と書かれているリンク先を「名前を付けて保存」してもよい。}して用いる。

例えば、次のようなCSVファイル（sample.csv）があったとする。\\
\begin{frameboxit}{160.0mm}
\begin{verbatim}
	aaa,"b""bb","c
	cc",d d
	"f,f"
\end{verbatim}
\end{frameboxit}

これを次のようにしてparsrc.shに掛けると、
第1列:元の値のあった行番号、第2列:元の値のあった列番号、第3列:値、
という3つの列から構成されるテキストデータに変換される。
\begin{screen}
	\verb|$ ./parsrc.sh sample.csv| \return \\
	\verb|1 1 aaa    | \\
	\verb|1 2 b"bb   | \\
	\verb|1 3 c\ncc  | ←値としての改行は``\verb|\n|''に変換される（オプションで変更可能） \\
	\verb|1 4 d d    | \\
	\verb|2 1 f,f    | \\
	\verb|$ |
\end{screen}

よって、後ろにパイプ越しにコマンドを繋げば「任意の行の任意の列の値を取得」もできるし、「全ての行について指定した列の値を抽出」などということもできる。
\begin{screen}
	(a) 1行目の3列目の値を取得 \\
	\verb!$ ./parsrc.sh sample.csv | grep '^1 3 ' | sed 's/^[^ ]* [^ ]* //'! \return \\
	\verb|c\ncc| \\
	\verb|$ | \\
	\\
	(b) 全ての行の1列目を抽出 \\
	\verb!$ ./parsrc.sh sample.csv | grep -E '^[^ ]+ 3 ' | sed 's/^[^ ]* [^ ]* //'! \return \\
	\verb|aaa    | \\
	\verb|f,f    | \\
	\verb|$ |
\end{screen}

\subsection*{解説}

CSVファイルは、Microsoft Excelとデータのやり取りをするには便利なフォーマットだが、AWKなどの標準UNIXコマンドで扱うにはかなり面倒だ。しかしできないわけではない。先程利用したparsrc.shというプログラムのソースコードは長すぎて載せられないが、どのようにしてデータの正規化\footnote{都合の良い形式に変換すること。この場合、UNIXコマンドで扱い易いように「行番号、列番号、値」という並びに変換した作業を指す。}をしたのかについて、概要を説明することにする。

\subsubsection*{CSVファイル（RFC 4180）の仕様を知る}

その前に、加工対象となるCSVファイルのフォーマット仕様について知っておく必要がある。CSVファイルの構造にはいくつかの方言があるのだが、最も一般的なものがRFC 4180で規定されている。Excelで扱えるCSVもこの形式に準拠したものだ。主な特徴は次のとおりである。
\begin{enumerate}
  \item 列はカンマ``\verb|,|''で区切り、行は改行文字で区切る。
  \item 値としてこれらの文字が含まれる場合は、その列全体をダブルクォーテーション``\verb|"|''で囲む。
  \item 値としてダブルクォーテーションが含まれる場合は、その列全体をダブルクォーテーション``\verb|"|''で囲んだうえで、値としてのダブルクォーテーション文字については1つにつき2つのダブルクォーテーションの連続\verb|""|で表現する。
\end{enumerate}

この3番目の仕様が、CSVパーサーを作る上で重要である。この仕様があるおかげで、値としての改行を見つけだすことができる。最初に示したCSVファイルの例をもう一度見てみよう。\\
\begin{frameboxit}{160.0mm}
	\verb|aaa,"b""bb","c  | ← ダブルクォーテーションが奇数個 \\
	\verb|cc",d d         | ← ダブルクォーテーションが奇数個 \\
	\verb|"f,f"           | ← ダブルクォーテーションが偶数個
\end{frameboxit}

最初の2行はダブルクォーテーションの数がそれぞれ奇数個である。これは列を囲っているダブルクォーテーションがその行単独では閉じてないということを意味している。つまり本来は同一行なのだが、値としての改行が含まれているために分割されてしまっているのだ。値としてのダブルクォーテーションは、元々の1つだったダブルクォーテーションを2個で表現しているから、1行にあるダブルクォーテーションの数が偶数か奇数かの状態に影響を及ぼさない。よって、\textbf{ダブルクォーテーションが奇数個の行が出現したら、次に奇数個の行が出現するまで、同一行}と判断することができる。

\subsubsection*{仕様に基づき、CSVパーサー``parsrc.sh''を実装する}

ここから先は、先ほど紹介したparsrc.shのソースコードを眺めながら読んでもらいたい。

\paragraph{1)値としての改行の処理}
この性質がわかれば正規化作業も見通しがつく。AWKで1行ずつダブルクォーテーション文字数を数え、奇数個の行が出てきたら、次にまた奇数個の行が出てくるまで行を結合していけばいい。ただし、単純に結合するとそこに値としての改行文字があったことがわからなくなってしまうので通常のテキストファイルには用いられないコントロールコード（SI:$<$0x0F$>$を選んだ）を挿んだうえで結合していく。

\paragraph{2)値としてのダブルクォーテーションの処理}
次は、値としてのカンマに反応しないように気をつけながら、行の中に含まれる各列を単独の行へと分解していく。基本的には行の中にカンマが出現するたびに改行に置換していけばいいのだが、2つの点に気をつけなければならない。1つは値としてのカンマを無視することであるが、これは先にダブルクォーテーションが出現していた場合は次のダブルクォーテーションが出現するまでに存在するカンマを無視するように正規表現置換をすればいい。ただ、値としてのダブルクォーテーションがあると失敗してしまうので、実は手順1)の前でそれ（ダブルクォーテーション文字の2連続）を別のコントロールコード（SO:$<$0x0E$>$とした）にエスケープしておくのだ。そしてもう一つ気をつけなければならないのが、元々の改行と列区切りカンマを置換して作った改行を区別できるようにしなければならないということだ。その目的で、元々の改行が出現した時点で更に第3のコントロールコード（行区切りを意味するRS:$<$0x1E$>$を選んだ）を挿むようにした。

\paragraph{3)列と行の数を数えて番号を付ける}
あとは、改行の数を数えれば作業は大方終了だ。改行が来るたびに列番号を1増やしてやればよいが、元々の改行の印として付けた第3のコントロールコードが来た時点で列番号を1に戻してやる。最後は、そうやって出力したコードに残っている第2のコントロールコードを戻す。これは何だったかというと値としてのダブルクォーテーションであった。最初、変換した時点では2個のダブルクォーテーションで表現されていたが、元々は1個のダブルクォーテーションを意味していたのだから1個に戻してやればよい。

概要は掴めただろうか。掴めなかったとしても、とにかくPOSIXの範囲のコマンドだけでできるんだということがわかれば十分だ。


\subsection*{参照}

\noindent
→\ref{recipe:JSON_parser}（JSONファイルを読み込む） \\
→\ref{recipe:XML_parser}（XML、HTMLファイルを読み込む）
