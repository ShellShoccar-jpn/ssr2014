\section{XML、HTMLファイルを読み込む}
\label{recipe:XML_parser}

\subsection*{問題}
\noindent
$\!\!\!\!\!$
\begin{grshfboxit}{160.0mm}
	WebAPIを叩いて得られたXMLファイルの任意の箇所の値を読み出したい。CSV、JSONと来たらやっぱりXMLもできるんでしょ？\\
	もしそれができたら、HTMLのスクレイピングもできるようになるのだろうか。
\end{grshfboxit}

\subsection*{回答}
XMLももちろん可能だ。sedやAWKを駆使すれば、やはりPOSIXの範囲でパーサーが作れる。ただ、HTMLのスクレイピングに流用できることはあまり期待しない方がいい。理由は、HTMLは閉じタグが無いなど文法が間違っていてもWebブラウザーが許容するおかげでそのままになっているものがあるし、更には$<$br$>$など、閉じタグが無いことが文法的にも認められているものがあり、そういったXML的に文法違反のものには通用しないからだ。

さて解説は後回しにして、制作したXMLパーサー``parsrx.sh''をダウンロード\footnote{\verb|https://github.com/ShellShoccar-jpn/Parsrs/blob/master/parsrx.sh|にアクセスし、そこにあるソースコードをコピー\&{}ペーストしてもよいし、あるいは``RAW''と書かれているリンク先を「名前を付けて保存」してもよい。}して使ってもらいたい。

例えば、次のようなXMLファイル（sample.xml）があったとする。\\
\begin{frameboxit}{160.0mm}
\begin{verbatim}
	<文具購入リスト 会員名="文具 太郎">
	  <購入品>はさみ</購入品>
	  <購入品>ノート(A4,無地)</購入品>
	  <購入品>シャープペンシル</購入品>
	  <購入品><取寄商品>替え芯</取寄商品></購入品>
	  <購入品>クリアファイル</購入品>
	  <購入品><取寄商品>６穴パンチ</取寄商品></購入品>
	</文具購入リスト>
\end{verbatim}
\end{frameboxit}

これを次のようにしてparsrx.shに掛けると、
第1列:元の値のあった場所（XPath形式\footnote{XMLデータは階層構造になっているので、同様に階層構造をとるファイルパスのようにして一行で書き表せる。その記法がXPathである。詳細は\verb|http://www.w3.org/TR/xpath-31/|参照。}）、第2列:値、
という2つの列から構成されるテキストデータに変換される。
\begin{screen}
	\verb|$ ./parsrx.sh sample.xml| \return \\
	\verb|/文具購入リスト/@会員名 文具 太郎| \\
	\verb|/文具購入リスト/購入品 はさみ| \\
	\verb|/文具購入リスト/購入品 ノート(A4,無地)| \\
	\verb|/文具購入リスト/購入品 シャープペンシル| \\
	\verb|/文具購入リスト/購入品/取寄商品 替え芯| \\
	\verb|/文具購入リスト/購入品| \\
	\verb|/文具購入リスト/購入品 クリアファイル| \\
	\verb|/文具購入リスト/購入品/取寄商品 ６穴パンチ| \\
	\verb|/文具購入リスト/購入品| \\
	\verb|/文具購入リスト \n  \n  \n  \n  \n  \n  \n| \\
	\verb|$ |
\end{screen}

よって、後ろにパイプ越しにコマンドを繋げば「任意の場所の値を取得」ができる。例えば次のような具合だ。
\begin{screen}
	(a) 購入品の2番目を取得する \\
	\verb!$ ./parsrx.sh sample.xml | awk '$1~/取寄商品$/' | sed '2s/^[^ ]* //'! \return \\
	\verb|ノート(A4,無地)| \\
	\verb|$ | \\
	\\
	(b) 全ての取寄商品名を抽出 \\
	\verb!$ ./parsrx.sh sample.xml | awk '$1~/取寄商品$/' | sed 's/^[^ ]* //'! \return \\
	\verb|替え芯| \\
	\verb|6穴パンチ| \\
	\verb|$ |
\end{screen}

\subsection*{解説}

POSIX範囲内で実装したCSV、JSONパーサーを作ったのなら当然次はXMLパーサーであるが、もちろん作れた。ただ、XMLはプロパティーとしての値とタグで囲まれた文字列としての値というように値が2種類あったり、コメントが許されていたりするため、さらに複雑であった。複雑であるため、こちらもどうやって実現したのかをどうしても知りたい人はソースコード読んでもらうことにして、説明は割愛する。

\subsubsection*{HTMLテキストへの流用}

最初でも触れたがHTMLテキストのパーサーとして使えるかどうかは場合による。厳密書かれたXHTMLになら使えるが、既に述べたように多くのWebブラウザーはいい加減なHTMLを許容するうえ、HTMLの規格自体が閉じタグ無しを許したりするのでそのようなHTMLテキストが与えられると、うまく動かないだろう。

ただし、「いい加減な記述が混ざっているHTMLではあるが、中にある正しく書かれた$<$table$>$の中身だけ取り出したい」という場合、sedコマンド等を使って予めその区間だけ切り出しておけば流用可能である。

\subsection*{参照}

\noindent
→\ref{recipe:CSV_parser}（CSVファイルを読み込む） \\
→\ref{recipe:JSON_parser}（JSONファイルを読み込む）
