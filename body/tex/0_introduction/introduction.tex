%\title{　}
%\author{　\\ 　\\ 　\\ 　\\ 　\\ 　\\ 　\\ 松浦リッチ研究所 \\ リッチ・ミカン}
%\maketitle


\thispagestyle{empty}
\begin{center}

　\\
　\\
　\\
　\\
　\\
　\\
　\\
　\\
　\\

\noindent
%%\Huge{\rellarge \textbf{Shell Script}\relsmall }
\Huge{\textbf{Shell Script ライトクックブック}} \\
\Huge{\textbf{　2014 改訂版}}
　\\
　\\
\noindent
\textbf{\LARGE{　}}

　\\
　\\
　\\
　\\
　\\
　\\

\noindent
\Large{リッチ・ミカン 著}

　\\
　\\

\begin{figure}[!h]
	\begin{center}
		\vspace{-1cm}
		\includegraphics*[scale=0.25]{tex/0_introduction/figs/MRL_logo_2007_outlined.eps}
		\vspace{-5cm}
	\end{center}
\end{figure}


\end{center}
\clearpage

\chapter{まえがき}

\section*{デプロイやその後の保守に苦しむプログラマーへ}

これはシェルスクリプト（Bourne Shell）のレシピ集である。だが単なるレシピ集なら既にいくらでも存在する。本書は、UNIX系OS向けアプリケーションを開発し、それをデプロイ（インストール）、或いはその後保守する人々が苦しまないようにするためのプログラミングに役立つレシピを主に取り揃えた。このような本を作るに至った経緯について、少し説明させてもらいたい。

\subsection*{とある会社との出会い}

私は元々UNIXやシェルスクリプトが好きで、それをネタに同人誌を作っていた。

2010年、その同人誌をイベント会場で出展していたとある会社の担当者に見せた。どんな仕事をやっているのかと尋ねたら、いわゆるデータベース（RDB）を使わず、シェルスクリプトだけでシステムを作り、しかもそれで商売が成り立っているという話だった。それはUNIXユーザーにとってとても理想的な姿ではあるが、そんなことが本当にできるのか疑問だった。

しかし、説明を聞けば聞く程信じるようになった。UNIX哲学に根ざした設計思想やシステム開発上の指針、そして結果として作られたシステムがその理屈通り、高いパフォーマンスを実際に叩きだしており、なんとも痛快だった。彼らは自分達が確立したこれら独自の開発手法に名前まで付けていた。

\subsection*{痛い目に散々遭ってきた人たち}

彼らの言ってる事が嘘ではないと思えたもう一つの理由は、披露された苦労話にとても現実味を感じられたからだった。やはり当初、このやり方が使えるということを説得するのが大変だったらしい。また、その開発手法が切れの味良い開発手法である秘密の一つに洗練された独自コマンド群を提供しているという特徴があるが、当初は2000個以上作ったものの使いきれずに淘汰が進み、本当に洗練された数十個だけが残ったという。確かに想像に難しくない話だ。

そんな苦労話の中で私が特に感銘を受けたのが、数々のハードウェアやUNIX系OSを渡り歩かざるを得なかった時のエピソードだった。顧客の要望で、使えるハードウェアやOSが指定されたり、変更されたりすることは珍しくなかったという。また入手性の問題により、異なるハードウェアやOSのマシンでシステムを構成せざるを得ないということもあったそうだ。こんな状況に置かれた彼らがどんな痛い目に遭うか。これまた想像に難しくない。

\subsection*{どこでも使えるコードしか書かない}

使えるコマンドやオプションの違いはもちろん、扱うデータの数値フォーマットの違いや文字コードの違い（Shift-JISやEUC-JP、ASCII、EBCDIC等々）など、開発したソフトを別種のOSで動かすたびに、いちいち躓いて痛い目に遭ってきたという。データは単に変換すれば解決するわけではない。例えば文字データであれば、変換先でどうしてもうまく扱えない文字というのが稀にあり、実際に動かし始めてその存在を知ることなったという。

こういった数々の問題に悩まされた結果として彼らが身に付けた教訓は「どこでも使えるコードしか書かない」、「問題を引き起こしそうなデータは避ける（別の方法で表現する）」だった。一見単純な発想に思えるが、私はそこに大きな感銘を受けた。普通の人なら「互換性がないからこの言語は使えない」といって使用を諦めてしまうところだが、彼らはその単純な発想を実践し、実際に今日まで乗り切ってきたという事実に対してだ。


\section*{POSIX原理主義のススメ}

この単純明快な発想に感銘を受けた私は、気が付けば彼らよりもエキセントリックにその発想を実践するようになっていた。それがPOSIX原理主義という考え方だ。

\subsection*{POSIXとは}

Portable Operating System Interfaceの略であるとされる。Xが無いが、本来末尾にあった``for uniX''が取れたのだろう（と、勝手に解釈している）。POSIXとは、UNIX系OS同士が互換性を持つために各々が守るべき表面部分の仕様をまとめた規格である。1990年、既に様々な系譜が存在していたUNIX系OSにおいて、それでも共通している仕様をできるだけ抜き出しながら、「これさえ守ればUNIXを名乗るOSで互換性のあるものが作れる（だから皆で守ろう）」という最低限の規格としてIEEEによってまとめられたものだと、私は理解している。その後も内容が更新されて現在に至っているものの、「最低限これだけは皆で守ろう」という立場ゆえに安易に変えるわけにはいかず、非常にゆっくりとした改訂がなされている。

\subsection*{OS乗り換えもバージョンアップも怖くない}

POSIXに書かれている内容を大雑把に言うならmanである。つまり、コマンドやシステムコールの仕様、データフォーマット等、ユーザーが意識すべき仕様がまとめられている。実在する各OSのmanはこれを元にして作られているといっても過言ではないだろう。従ってPOSIXに明記されている仕様の範囲でソフトウェアを作れば、UNIXを名乗るOSになら殆ど何も恐れることなく持ち運ぶことができる。

また、OSのバージョンアップも特に恐れなくていい。OS開発元からバージョンアップ勧告が出たら恐れずやればいいし、強制的にバージョンアップがなされるレンタルサーバーにも安心して置ける。なぜなら「最低限これだけは皆で守ろう」という仕様からなる規格なのだから、OS開発元もPOSIXに書かれている仕様だけは、例え他の仕様を変更しても極力維持しようとする。UNIX系OSであり続けるために。逆に、セキュリティー脆弱性が見つかったのにいつまでたってもOS開発元が修正版をリリースしないというなら躊躇なく別OSに引っ越すこともできる。なぜなら引っ越し先のOSもPOSIXに書かれている仕様は極力守っているからだ。もちろんPOSIXの仕様が変わってしまったら元も子も無いのだが、先程も述べたようにPOSIXは「最低限これだけは皆で守ろう」という仕様からなる規格であるために易々と変更を促すわけにもいかず、結果として10年、20年の規模で通用する規格になっている。

OS乗り換えにもバージョンアップにも強いということは、つまり場所も時代も問わないということである。このような性質を私は「時空を超えた可搬性」と呼んでいるが、POSIXにはそれが秘められているのである。

\subsection*{POSIX原理主義の言語 -- Bourneシェルスクリプト}

本書はシェルスクリプトのレシピ集であると冒頭で述べたが、数ある言語の中でなぜシェルスクリプト（bashその他ではなくBourne Shell）なのかここでようやく説明することができる。理由はPOSIX規格に存在する数少ない言語の一つだからである。POSIXに存在するということは、先に述べた「時空を超えた可搬性」を享受できるということだ。もちろんPOSIXの範囲のシェル文法とコマンドだけを使うことが前提ではあるが。

巷ではよく「シェルスクリプトは環境依存が激しいから……」などと敬遠され、書き捨てるプログラムのための言語とみなされる。だが、書き捨てず、10年、20年持たせるに相応しい言語こそシェルスクリプトだ。

因みにPOSIX規格で存在する言語には他にC言語（C99）もある。よってC言語を使ってもPOSIX原理主義は実践できるのだが、例えばポインターの概念を理解しなければならなかったりコンパイルが必要だったりと、手軽さではシェルスクリプトに及ばないのが難点だ。開発者にとっては危険なバグが入り込みやすいし、運用者にとってみればインストール対象のコンピューター上でコンパイルが通らずに何時間もの格闘を余儀なくされることなど珍しくない。これはCという言語が、時にコンピューターの内部構造を深く意識しながら書かねばならない言語であることに起因する。

もちろん欠点ばかりではない。C言語は、シェルスクリプトには太刀打ちできない処理速度を持っている。ただ、シェルスクリプトにおいてもsedやAWK他、既存のPOSIXコマンドを上手に活用すれば実用的な速度は十分発揮できる。なぜなら既存のコマンドは、どれもC言語で作られているからだ。この後で紹介する実際の制作アプリケーションを試してもらえば、シェルスクリプトで作っても申し分無い処理速度が出せることに納得してもらえると思う。

以上、シェルスクリプトによる\textbf{POSIX原理主義の利点}をまとめると次のとおりだ。
\begin{itemize}
  \item どのUNIX系OSでも動く
  \item 10年、20年先も動く
  \item コピー一発、デプロイ完了
\end{itemize}


\subsection*{POSIX原理主義に基づくアプリケーションたち}

POSIX原理主義は机上の空論などではない。既にこの主義を実践して制作したアプリケーションがいくつかあるが、代表的な2つを紹介しよう。どちらも、POSIX原理主義に基づくシェルスクリプトで書かれている。

\subsubsection*{ショッピングカート「シェルショッカー1号男」}

私はもともと同人作家であるので年二回の例のイベント（コミックマーケット）で本を頒布している。そして会場に来られない人向けに通販もやっている。ショッピングカートプログラムが必要になるところだが、言語はPerlやPHPで、データベースとしてMySQLを必要とするといったいわゆるLAMP環境のものしかない。一つの同人サークルとして細々やりたいだけなのにデータベースは大げさだし、同人誌頒布に特化した機能がなくて使いづらいし、そもそもシェルスクリプトでシステム開発する本を頒布するのにPerlやPHPその他を使うなんて何のジョークだ! ということで作ったものがシェルショッカー1号男（=シェルスクリプト製ショッピングカートversion1の意味）だ。

本書を買ってくれた方にはもはや不要だが、冷やかしに是非
\begin{quotation}
\verb|http://richlab.org/coterie/ssr2.html|
\end{quotation}
を訪れてみてもらいたい。（注文する前までの操作ならタダ）注文までいかないとお目に掛かれないが、PayPal APIと連携してクレジットカード決済することも可能だ。ソースコードもGitHubで公開している\footnote{\verb|https://github.com/ShellShoccar-jpn/shellshoccar1|}。

\begin{figure}[htb]
	\begin{center}
		\vspace{10mm}
		\includegraphics*[scale=0.30]{tex/0_introduction/figs/ShellShoccar1_web.eps}
		\vspace{0mm}
		\caption{シェルショッカー1号男（ショッピングカート）を搭載したページ}
		\label{fig:ShellShoccar1_web}
		\vspace{0mm}
	\end{center}
\end{figure}

\paragraph{POSIX原理主義と実利のトレードオフ}

ツッコミが来ると思うので予め断っておくが、郵便番号を住所に変換するデータを取得するために内部ではPOSIXにはないcurlコマンドや、注文確認メールを送るためにこれまたPOSIX外のsendmailコマンドを使っており、そしてそもそもWeb（CGI）を使っている時点POSIXを逸脱しているだろうと指摘されても仕方がない。実はPOSIXには、通信系のコマンドが殆ど用意されていないという弱点がある。POSIX規格に完璧に遵守しようと思ったら、現状ではC言語でcurlやsendmailやhttpdサーバーを再発明しない限り不可能である。

それらに関しては実利を取ることを甘受するが、それでも代替品があって容易に乗り換えられるという担保は確保している。curlの代替品としてはwgetやFreeBSDのfetchコマンドを検討し、sendmailコマンドはオリジナルのsendmailサーバーの他、Postfixやqmail、eximなど、主要MTAには同等のコマンドが存在するし、WebサーバーにもApacheの他、nginxやlighttpd等代わりのものにすぐに移れるように作り、またバージョンアップが起こっても極力影響を受けないように基本的な機能しか使わないようにして作るのである。

\subsubsection*{東京メトロ列車在線状況確認アプリ「メトロパイパー」}

2014年、東京メトロが駅施設情報や列車情報をJSON形式で出力するWeb APIをオープンデータとして公開し、これを活用するコンテストを開催した。本アプリケーションは、そのコンテストにシェルスクリプトで挑んだ応募作品である。
\begin{quotation}
\verb|http://metropiper.com/|
\end{quotation}

メトロパイパーは、東京メトロの車両全車両が現在どの駅（駅間）に在線しているかという情報（在線情報）を問い合わせ、JSONで返された在線情報を読み解き、HTML化して画面に表示するというものである。POSIXの範囲には通信系コマンドが殆ど無いという事情により、Web APIへのアクセスにはcurlコマンドを使っているものの、JSONの解析はsedやAWKを駆使して独自に行っている（→\ref{recipe:JSON_parser}参照）。また、こちらもソースコードをGitHubで公開している\footnote{\verb|https://github.com/ShellShoccar-jpn/metropiper|}。

\begin{figure}[htb]
	\begin{center}
		\vspace{10mm}
		\includegraphics*[scale=0.30]{tex/0_introduction/figs/metropiper_web.eps}
		\vspace{0mm}
		\caption{メトロパイパーの動作画面}
		\label{fig:metropiper_web}
		\vspace{0mm}
	\end{center}
\end{figure}

\paragraph{何十万もの人々が路頭に迷わないために}

メトロパーパーの最大の特長は、10年20年の長きに渡って動き続けられることである。もしこのアプリケーションが東京メトロの公式サービスになったとしよう。都心の大動脈たる鉄道を司る会社ゆえ、何十万人、あるいは何百万人ものユーザーを抱えることになり、極めて公共性の高いサービスになるだろう。現在の鉄道経路検索サービスなどは、それをあてにして一日のスケジュールを決める人がいるように、本サービスもそのように生活の一部に溶け込む可能性がある。

もしそうなった時、突然依存している言語やライブラリー、あるいはOSに脆弱性が見つかり、アップデートパッチが出たら、即時の対応を迫られるだろう。しかし、本当にアップデートしても大丈夫なのだろうか。いくら脆弱性が解消されるとはいえ、アップデートの弊害でソフトウェアが動かなくなり、修正するまでサービス停止に追い込まれてしまったら? それに生活を依存している何十万もの人々が路頭に迷い大混乱が起きてしまう。鉄道情報程度ならまだいいが、もしそれが運行システムだったり、金融システムだったり、医療システムだったりしたら……。
　しかし、POSIX原理主義に基づいた作り方をしていれば、先も述べたようにほぼ安心してアップデートができるし、何ならOSごと乗り換えることだって簡単にできる。心配は皆無とまでは言わないが、圧倒的に素早い対応ができるだろう。もともとこのコンテストはロンドンオリンピックに際して行われた同様のコンテストに倣って企画されたらしいが、メトロパイパーはWeb APIの公開さえ続く限り2020年の東京オリンピックまで何の苦労もなく動かし続けられる自信がある。果たして2020年まで動き続ける作品は他にどれだけあるだろうか。

\paragraph{依存ソフトの仕様変更はアンコントローラブル}

このようなメトロパイパーの特長を説明すると、「でも新路線ができたりして路線仕様が変わったら意味ないじゃん」と言われたりもする。確かに、丸ノ内線、千代田線、南北線、有楽町・新都心線などの分岐を持つ路線には個別対応するプログラムになった。

しかし、飽くまで公式サービスになった時の話として考えてみてもらいたい。路線が増えるなどといった路線の仕様変更は自社でコントロールできる話であるのに対し、依存言語等のバージョンアップはそのソフトウェア開発団体の一存で決まりこちらの会社の都合など聞いてくれはしない。大抵は「〇年×月までに移行してくださいとか、△△の機能が削除されます」といったアナウンスがなされるが、細かな機能の追加削除に関してはアナウンス漏れもあるだろうし、緊急時にはそれこそゼロデイでアップデートを迫られる。まさにアンコントローラブルだ。

例えばPHPは5.2から5.3へのアップデートによって比較的多くの機能で下位互換性が損なわれ、開発者に大きなインパクトをもたらした。このようにして依存ソフトウェアの変更に、我々プログラマー達は散々苦しめられてきた。この本が提唱するPOSIX原理主義プログラミングによって、少しでもデプロイや保守の苦労から解放される人が増えれば幸いである。

\subsection*{POSIX原理主義に対する誤解}

POSIX原理主義の説明をしていると、次のような反論を受けることがある。
\begin{quotation}
	\noindent
	いくらPOSIXの範囲で独自コマンドを作っても、それを他人に提供すれば（=他人の作った独自コマンドを使えば）、アンコントローラブルにバージョンアップがなされるので同じことではないか。
\end{quotation}

確かに、ここまでの説明ならばそう解釈されても仕方が無い。だが実際は、独自コマンドを使うにあたっては次のような条件が付く。\begin{quotation}
	\noindent
	使い始めたら、自分の手足の如く、自分で扱い方を理解し、責任を持つこと。
\end{quotation}

「自分の手足の如く」というニュアンスを理解してもらいたい。自分の手足の血管がどうなっていて、骨がどうなっているといったことまで知っているわけではないが、例えば「人より関節が柔らかくて細いパイプの中にも拳を入れられる」といった特徴やクセを理解しているといった意味である。コマンドで言うなら「コード中身1行1行まで知り尽くしているわけではないが、その動作やクセは大体把握できており、使い方の工夫もトラブル対応もある程度自分でできる」という状態だ。

よって\textbf{POSIX原理主義においては、他人の作った独自コマンドであっても、それを手に入れたユーザーは自分の作ったコマンドとして扱わなければならない}というルールを定めている。その為、本書で紹介している拙作の独自コマンドは全てパブリックドメイン（ライセンス放棄状態）で提供している。

\subsubsection*{20年後など、誰も責任とってはくれない}

ソフトウェアに限った話でもないが、\textbf{悲劇が生まれる原因は、他人が作ったものに過度に依存しすぎていること}にあると私は思う。技術が高度化した現代においては、道具のブラックボックス化が進み、特にその傾向強い。また、利用者も道具の特性まで興味を示す余裕がなくなってしまった。POSIX原理主義は「原理主義」という名に相応しく、そういった流れに抗う主義である。

そもそも、20年も先のことを保証してくれるものなど国の社会保障くらいである\footnote{ちなみにこの一文は、確実性が疑問視されている現状の社会保障制度に対する皮肉である。}。「20年耐えうる性能です」とは主張しても、「20年後も私が責任を持ちます」などという人はおそらく居ない。20年後にも生きて同じ職業を続けている保証など無いのだから。それは本書の筆者とて同じである。

それならば20年間本当に動き続ける保証のあるソフトウェアを手に入れるにはどうすればいいのか。答えは、他人に頼らず自分で保守できる知恵を身に付けること、だ。


\section*{本書の効果的な活用方法}

最後に、レシピ集である本書の具体的な使いこなし方を記しておく。

\subsection*{シェルスクリプトの基礎については他書を併読する}

本書はレシピ集である。つまり「目の前の課題に対し、既存の文法やコマンドをどのように駆使すればそれが解決できるか」を紹介する本である。

従って、「既存の文法」や「コマンド」といったものを予め知っていなければ、本書のレシピを理解し、活用することは難しい。できればそれらについてもページを割いて説明したいところではあるが、文法やコマンドを解説しているシェルスクリプトの教本としては既に多数の良書が存在する。

シェルスクリプトにまだあまり馴染みの無い方には不便を掛けてしまい大変申し訳ないが、本書のレシピを理解するのが難しいのであれば、書店のコンピューター書売り場（UNIX関係）で良書を探すか、Web上でシェススクリプトについて解説しているページなどと一緒にご覧頂きたい。

\subsection*{POSIX規格を見ながら開発する}

本書を参考にしながら、時空を超えた可搬性を持ち合わせたプログラムを実際に開発するには、POSIX規格が具体的にどのような内容になっているのかを常に確信しながら進めることが必要不可欠である。

\subsubsection*{Webページの場所}

POSIXの内容は、誰でもWeb上で簡単に閲覧することができる。実際にPOSIX原理主義に基づいてアプリケーションを制作する際には、本書と併せ、POSIXの原典を見ながら進めるべきである。

検索エンジン等で``opengroup POSIX''という2つのワードで検索すれば、``Posix - The Open Group''という名のページがすぐに見つかるだろう。執筆時の最新版は2013年版であり、
\begin{quotation}
\verb|http://pubs.opengroup.org/onlinepubs/9699919799/|
\end{quotation}
というURLである。

\begin{figure}[htb]
	\begin{center}
		\vspace{10mm}
		\includegraphics*[scale=0.30]{tex/0_introduction/figs/POSIX_web.eps}
		\vspace{0mm}
		\caption{POSIX規格の原典“Posix - The Open Group”}
		\label{fig:POSIX_web}
		\vspace{0mm}
	\end{center}
\end{figure}

\subsubsection*{コマンドマニュアル}

最もお世話になる機会が多いと思われるコマンド仕様のページは、左上のメニューから``Shell \&{} Utilities''を選び、続いて左下に現れる``Utilities''を選べば出てくる。

尚、文章は全て英語である。もし英語が苦手という人は、``FreeBSD 日本語 man''や``Linux JM''（Linuxの日本語マニュアル）で検索される日本語マニュアルのページと併読するのがよいだろう。これらのmanで書かれている内容は殆どPOSIXのページに書かれている内容のスーパーセット（上位互換）になっているので、「日本語で書かれているこのコマンドオプションはPOSIXにも載っている」などと見比べながら確認するとよい。

\subsubsection*{用いるのはBourne「系」シェルスクリプトである}

ここまで来て言うまでもないが、開発で使用する言語はシェルスクリプト、しかもBourneシェルのシェルスクリプトである。Perl、PHP、Ruby、Pythonその他のLightweight Languageと呼ばれる言語は一切用いない。理由はPOSIXで規定されているのがBourneシェルだからである。

ただし、bash、dash、ksh、zsh等の（Cシェルではない）\textbf{Bourne系のシェルを使ってはならないということではない。}これらは全てBourneシェルの上位互換であり単にそれらのシェルが独自拡張した機能を使わないというだけだ。同じ理由で、GNU AWK等のコマンドももちろん使って構わない。

\subsection*{コマンドセット``Open usp Tukubai''を活用する}

本書を読み進めていくと``Open usp Tukubai''という用語が出てくる。これは、USP研究所からリリースされているシェルスクリプト開発者向けコマンドセットの名称である\footnote{公式サイト→\verb|https://uec.usp-lab.com/TUKUBAI/CGI/TUKUBAI.CGI?POMPA=ABOUT|。尚、高いパフォーマンスを発揮する有償版``usp Tukubai''というものも存在する。}。このコマンドセットは、シェルスクリプトをプログラミング言語として強化するうえで大変便利なものであり、本書で紹介するレシピのいくつかでは、そこに収録されているコマンド（Tukubaiコマンド）を利用している。

しかしながらOpen usp Tukubai（無償版）のTukubaiコマンドは、全てその中身がPythonで書かれており、本書が提唱するPOSIX原理主義を貫くことができない。そんな中、やはりPOSIX原理主義に賛同している一人である321516氏によって、これらのコマンドをPOSIXの範囲で動くシェルスクリプトに移植する作業が行われている\footnote{GitHub上で公開中→\verb|https://github.com/ShellSchoccar-jpn/Open-usp-Tukubai/tree/master/COMMANDS.SH|}。本書のレシピで利用しているTukubaiコマンドは全て、POSIXクローン版として移植の完了しているものであるので、安心してPOSIX原理主義の実力を見てもらいたい。

また、この場を借りて321516氏、そしてオリジナルを公開しているUSP研究所に感謝したい。

\subsection*{制約を理解する}

道具を使いこなすコツの一つは、その道具の性質および、できることできないことを正しく理解することである。本書についても若干の制約事項があるので述べておく。

\subsubsection*{POSIX準拠であればいいとはいえない例外}

本書は、\textbf{基本的にはPOSIX規格に準拠する内容}であるように注意を払っている。より具体的には、``IEEE Std 1003.1''という規格への準拠である。これはもちろん、「時空を超えた互換性」等の利点を引き出すためである。

だが、「基本的に」という断りを付けた。これには理由がある。歴史上、POSIXは各種UNIX系OSで共通している仕様を抜き出す形でまとめられた規格であるが、相反する仕様を持っていることが原因でどちらかの使用を選ばざるを得なかったものが若干ある（trコマンドの仕様など）。選ばれなかった側のUNIX系OSが現存しない（=サポート終了している）のであればよいが、現行品もあり、そのようなOSを無視しては本末転倒である。

そこで、いくらPOSIX規格で明記さてれているものであっても、本書では全てを推奨しているわけではない。ただしそのようなものについては個別に明記している。

\subsubsection*{動作試験環境}

紹介しているレシピは全てのUNIX系OS上で動くことを目標にしているので、本来であれば全てのUNIX系OS上でレシピを試食しなければならない。しかし現実的にそれは不可能であるため、もしかするとお使いの環境によってはご賞味頂けないレシピがあるかもしれないことをご了承いただきたい。レシピを試食した主なOSは、FreeBSD 9～10、CentOS 5～7、AIX、Raspbianなどである。


\subsubsection*{おことわり}

細心（最新）の注意を払ってはいるもののその他にも、間違った記憶、あるいは執筆後に仕様が変更されることによって\textbf{正しく動作しない内容が含まれている可能性}がある。不幸にもなおそのような箇所を見つけてしまった場合は下記の宛先へこっそりツッコミなどお寄せ頂きたい。
\begin{verbatim}
	richmikan@richlab.org
\end{verbatim}
